# 53.最大子数组和

## 方法：动态规划 Kadane算法：

```
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int maxSum = nums[0];
        int curSum = nums[0];
        
        for (int i = 1; i < n; i++) {
            // 动态转移方程
            curSum = Math.max(nums[i], curSum + nums[i]);
            maxSum = Math.max(maxSum, curSum);
        }
        return maxSum;
    }
}

```

1. **初始化**

    - `curSum`（以当前元素结尾的最大子数组和），初始化为 `nums[0]`。
    - `maxSum`（全局最大子数组和），初始化为 `nums[0]`。

2. **状态转移**
   遍历数组（从索引 1 开始）：

    - 如果之前的 `curSum` 大于 0，那么继续加上当前元素；
    - 否则直接从当前元素重新开始。
    - 也就是：

   ```
   curSum = Math.max(nums[i], curSum + nums[i]);
   ```

3. **更新全局最大值**

    - `maxSum = Math.max(maxSum, curSum);`
    - 这样保证即使后续子数组和下降，之前出现过的最大值也被保存。

4. **最终返回**

    - `maxSum` 就是整个数组的最大连续子数组和。

------

### 和贪心的关系

“有点像贪心”，这个想法是 **正确的** 👍：

- 动态规划版本是严格的数学推导（DP 转移方程）。
- 但如果从“直觉”角度理解：
    - 每一步我只关心“要不要把当前数接到前面的和上”，
    - 这就是一种局部最优策略，最终也能得到全局最优。
      所以说 Kadane 算法既可以当作 DP，也可以当作一种“贪心的 DP”。

------

### 🔍 Kadane算法中的贪心策略：

**在每个位置i的贪心选择：**

java

```
curSum = Math.max(nums[i], curSum + nums[i])
```



这实际上是在做**局部最优决策**：

- **选择1**：只取当前元素`nums[i]`（如果前面的是负数）
- **选择2**：延续前面的子数组`curSum + nums[i]`（如果前面的是正数）

**选择标准**：哪个能让我**当前位置**的和更大

### 💡 为什么这能保证全局最优？

虽然每个步骤只考虑当前位置，但由于：

1. **`maxSum`记录了所有局部最优中的最大值**
2. **最大子数组必然以某个位置结尾**
3. **我们计算了以每个位置结尾的最大子数组和**

所以最终`maxSum`就是全局最优解。

✅ 面试时最佳回答套路：

> “我用 Kadane 算法解决。核心是维护一个 `curSum` 表示以当前元素结尾的最大子数组和，转移方程是 `curSum = max(nums[i], curSum + nums[i])`。同时维护一个 `maxSum` 作为全局最大值，每次更新。时间 O(n)，空间 O(1)。直观上也能理解为一种贪心策略：只要之前的和对结果有帮助就保留，否则就重新开始。”

我的理解：首先初始化以当前元素结尾的数组元素和，初始化全局中连续数组元素最大和，让这两个数组都初始化为0索引下的元素，所以遍历从1索引开始，通过动态规划算法，判断如果以当前元素结尾的数组和与当前元素比较，如果前者大，那么就延续，如果前者 小，通过转移方程cursum= Math.max（num[i],num[i]+cursum）,不能再进行后推相加，而是以当前元素重新开始。通过全局最大元素和与当前元素结尾的数组和比较不断更新全局最大数组和，因为当前元素结尾数组和是不断遍历走下去的，所以如果中间出现了连续元素和最大，然后更新全局最大和，但是后面延续元素可能 导致总和变小，并且全局是在不断更新的，结果其实还是连续元素和最大时候，所以最终直接返回全局最大,所以我感觉有点贪心算法感觉，局部最优不断更新