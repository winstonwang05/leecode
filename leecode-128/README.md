# 128.最长连续序列

## 思路一：排序解法

```
class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        Arrays.sort(nums);

        int maxLen = 1;
        int curLen = 1;

        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) {
                continue; // 跳过重复
            } else if (nums[i] == nums[i - 1] + 1) {
                curLen++;
            } else {
                maxLen = Math.max(maxLen, curLen);
                curLen = 1;
            }
        }
        return Math.max(maxLen, curLen);
    }
}

```

首先对数组判空处理，然后将数组排序处理，接着需要初始化当前最大连续序列计数器和全局最大连续序列计数器 ，都初始化为1，然后从第二个元素开始处理

接着从第二个索引的元素值开始遍历，如果nums[i] == nums[i - 1]，说明与上一个元素值相等，直接跳过就行；如果是nums[i] == nums[i - 1] + 1，正好满足题目要求 当前计数 +1

如果都不满足上述要求，那就是当前索引下的元素比上一个大，所以我们需要通过当前计数器（已经完成遍历了的并且满足条件的计数结果）与全局最大计数器比较来更新全局最大计数器，并重新初始化当前计数为1

**·**最后遍历完毕之后，不能直接返回全局最大，因为如果是数组最后一段是连续最长，就不会走更新全局最大，所以我们需要用当前连续最大再和全局最大计数器比较

时间复杂度：O(n log n)

## 思路二：哈希表

```
import java.util.HashSet;
import java.util.Set;

class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) return 0;

        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }

        int longest = 0;
        for (int num : set) {
            // 只从连续序列的起点开始
            if (!set.contains(num - 1)) {
                int currentNum = num;
                int count = 1;

                while (set.contains(currentNum + 1)) {
                    currentNum++;
                    count++;
                }

                longest = Math.max(longest, count);
            }
        }
        return longest;
    }
}

```

## ✅ 最长连续序列（LeetCode 128）思路理解（精炼版）

首先进行**代码健壮性判断**：
如果数组为空，直接返回长度 `0`，防止出现空指针或无效计算。

接着，将数组中的所有元素放入一个 `HashSet` 集合中。
这样做有两个目的：

1. **去重**：避免重复元素影响结果；
2. **加速查找**：`HashSet` 查找效率是 O(1)。

然后，初始化全局最大连续序列长度 `maxLen = 0`。

------

### 🔍 核心逻辑

开始遍历 `Set` 集合中的每一个元素 `num`。
首先计算 `num - 1`，判断该值是否存在于集合中：

- 如果存在，说明当前 `num` 不是连续序列的起点（例如 `3` 前面有 `2`，那 `3` 属于 `[1, 2, 3, 4]` 中的一部分），
  直接跳过当前元素；
- 如果不存在，说明当前 `num` 是一个连续序列的起点。

------

### 🔢 当找到一个起点时：

1. 定义一个变量 `cur = num`，保证后续操作不会修改原始遍历元素；
2. 初始化当前连续序列长度 `count = 1`（包括当前元素本身）；
3. 不断判断 `set` 中是否包含 `cur + 1`：
    - 如果包含，说明序列还在延续：
        - `cur++`
        - `count++`
    - 如果不包含，说明序列中断，退出循环。

------

### 🔁 更新全局最大值

每次得到一段连续序列后，通过：

```
maxLen = Math.max(maxLen, count);
```

更新全局最长序列的长度。

当所有元素都遍历完成后，返回 `maxLen` 即可。

------

### 💡 为什么要判断 `num - 1` 不存在？

这是为了找到每个连续序列的 **起点**。
如果不加这一步，就会从序列中间多次重复统计。
而加上这个判断后，每个序列只会被遍历 **一次完整长度**，
从而保证算法整体复杂度是 **O(n)**。

------

### ⚙️ 算法优点总结

1. **每个元素最多被访问两次**：
    - 一次是外层遍历；
    - 一次是作为起点延伸连续序列；
2. **不会重复计算中间元素**；
3. **查找效率高**，得益于 `HashSet` 的 O(1) 查询；
4. **整体复杂度：**
    - 时间复杂度：O(n)
    - 空间复杂度：O(n)

------

### ✅ 一句话总结：

> “先用 HashSet 去重并快速查找，再从每个可能的起点出发向后延伸连续序列，最终取最大长度。”

## 🌰 举例演示

输入：`[100, 4, 200, 1, 3, 2]`

- `set = {100, 4, 200, 1, 3, 2}`
- 遍历：
    - `100` → `99` 不在集合 → 起点 → 序列长度 1。
    - `4` → `3` 在集合 → 跳过。
    - `200` → `199` 不在集合 → 起点 → 序列长度 1。
    - `1` → `0` 不在集合 → 起点 → 扩展到 `2,3,4` → 序列长度 4。
    - `3`、`2` → 都会被跳过。
- 最终 `maxLen = 4`。

首先代码健壮性判断，如果数组为空，返回长度为0；接着将数组里的元素都放入Set集合中，因为Set集合是去重的，所以避免遍历时遇到相同元素不进行操作，还有就是Set集合搜索快；然后需要初始化全局最大连续序列长度为0；接着遍历Set集合每一个元素，首先得到当前遍历到的元素大小 -1结果，判断这个结果是否在Set集合中存在，如果存在就跳过了不执行，继续遍历下一个Set集合中元素，如果不存在，那么就把当前遍历到的元素赋值给一个cur变量，保证纯净环境，并初始化当前连续序列长度为1（为1时包括当前遍历到的元素），为何需要判断遍历到当前的元素 - 1不存在 ？原因就是得到集合中这些连续序列的最开始起点，因为最开始起点大小- 1在集合中是不存在的；接着再遍历Set集合，如果不包含当前元素 +1大小的结果值就结束，满足的就当前连续序列长度+1，并把当前遍历到当前的元素cur ++得到下一个连续的元素继续遍历，也就是cur就是保证最开始遍历的元素不被改变，保证纯净；最里层循环遍历完之后更新全局最大，最后最外层遍历完成，返回maxLen；总结下来优点有：每一个元素最多遍历两次，一次是最外层（每个元素必经之路），一次是如果当前元素 -1 在集合中不存在，说明当前元素就是最开始起点，再遍历一次Set集合；得到最开始起点，不会重复得到中间元素；查询效率高

