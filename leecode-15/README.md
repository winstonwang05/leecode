# 15.三数之和

这道题要求找出数组中所有三个数之和为 0 的不重复三元组。
**为了实现去重和提高效率，我们采用排序 + 双指针的方式。**

------

### 一、排序与准备

首先对数组进行排序。
排序的目的是：

1. 方便后续使用双指针；
2. 让相同元素相邻，便于去重。

同时我们创建一个 `List<List<Integer>> res` 结果集用于存储所有符合条件的三元组。

------

### 二、外层循环：固定第一个数

使用 `for (int i = 0; i < nums.length - 2; i++)` 遍历数组。
为什么只遍历到 `length - 2`？

> 因为固定一个数后，后面还需要至少两个数来组成三元组。
>  当 i 指向倒数第三个元素时，剩下正好两个可选；如果再往后就不够三个数了。

#### 外层去重：

如果当前元素和前一个元素相同（`nums[i] == nums[i - 1]` 且 `i > 0`），说明这个数作为固定值的情况已经处理过，为了避免重复结果，直接 `continue`。

------

### 三、内层循环：双指针查找另外两个数

初始化：

```
int left = i + 1;
int right = nums.length - 1;
```

然后进入 while 循环：

```
while (left < right) {
    int sum = nums[i] + nums[left] + nums[right];
}
```

#### 1️⃣ 如果 `sum == 0`

说明找到一组符合条件的三元组，将其加入结果集。

接着要进行**双指针去重**：

- 如果左指针下一个元素相同，就不断右移 `left++`；
- 如果右指针前一个元素相同，就不断左移 `right--`；
- 去重结束后，再正常移动指针：`left++`，`right--`。

------

#### 2️⃣ 如果 `sum < 0`

说明当前和偏小，需要更大的值，于是右移左指针 `left++`。

#### 3️⃣ 如果 `sum > 0`

说明当前和偏大，需要更小的值，于是左移右指针 `right--`。

------

### 四、总结

最终外层循环结束后返回结果集 `res`。

------

### ✨ 思路总结一句话：

> 排序数组 → 固定一个数 → 双指针从两端逼近 → 调整左右指针 → 通过两层去重避免重复结果。

------

### 🔁 两个“去重”的区别：

| 去重位置 | 作用对象                                | 触发条件               | 用法                   |
| -------- | --------------------------------------- | ---------------------- | ---------------------- |
| 外层去重 | 固定元素 `nums[i]`                      | `nums[i] == nums[i-1]` | `if` 跳过整个循环      |
| 内层去重 | 双指针元素 `nums[left]` / `nums[right]` | 相邻相同元素           | `while` 连续跳过相同值 |

我的理解：首先根据题目要求需要数组中任意三个索引下的元素值之和为0，并且需要去重处理，所以我们将数组排序，排序之后方便使用双指针进行遍历实现去重；实现的思路就是：我们遍历整个数组也就是最外层循环，来固定当前遍历到的数，然后内层循环通过双指针移动来寻找满足条件的数；第一步初始化集合泛型就是存储满足条件的三元之和元素，最后返回集合；然后将数组排序；第二步，最外层循环，遍历结束位置在数组倒数第三个索引，原因是：我们固定一个数之后，需要通过双指针遍历其他元素，当固定到倒数第三个索引下的元素值时候，仅剩下两个元素，双指针可以指向，但是如果再遍历下一个元素就会双指针就不能指向了，就一个位置；然后就是去重处理，从0索引之后的元素值（不包括0索引下的）如果nums[i] == nums[i-1]此时i是>0正如前面所说，那么就要去重也就是跳过；然后初始化双指针，左指针从1索引开始走，右指针从最右边开始走，如果双指针指向的元素值之和+当前遍历到的固定元素值=0满足条件，需要添加到结果集中，接着去重，如果左指针遇到下一个元素相同就右移，如果右指针遇到相同的就左移，当然两个的条件都还需要left < right；保证左右指针的不是一直移动，有结束条件，所以需要移动，然后还需要将左右指针移动左指针右移，右指针左移，意思就是如果遇到相同的会先移动一次到它下一个与他相同元素的位置，然后再移动一次，没遇到就不会走去重，直接右移，去重是一个循环不断尝试找相同就跳过，而最开始去重是if因为其最外层已经有for循环实现；如果三个之和小于0，说明需要左指针右移；如果三个之和大于0，说明需要右指针左移使值变小；因为就是排序了；最后最外层遍历结束返回结果集；我个人总结下来：有两个去重，一个是最外层遍历固定，一个是双指针移动时候

### 为何最外层不用Set集合封装三元组？





假设我们用 `Set<List<Integer>>` 来存三元组，确实会遇到两个问题：

### 1. **三元组顺序影响去重**

java

```
Arrays.asList(-1, 0, 1) ≠ Arrays.asList(0, -1, 1)
```

即使这两个三元组元素相同，但顺序不同，Set 会认为它们是不同的对象。

## 🎯 面试口语化表达（精炼版）

> “我们通过排序和跳过重复值，已经在遍历过程中高效地实现了去重，避免了重复三元组的加入。如果用 Set 集合来去重，虽然也能实现功能，但每次加入三元组前都必须先对其排序，才能保证 Set 能正确识别重复组合，这不仅增加了额外的时间开销，也违背了我们排序 + 双指针本身的高效设计初衷。所以我更倾向于在逻辑层面处理去重，而不是依赖额外的数据结构。”