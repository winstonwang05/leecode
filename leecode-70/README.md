# 70.爬楼梯

### 1. 问题分析的关键洞察

要到达第n阶，你只能从：

- **第n-1阶**爬1阶上来
- **第n-2阶**爬2阶上来

因此：**到达n阶的方法数 = 到达(n-1)阶的方法数 + 到达(n-2)阶的方法数**

```
class Solution {
    public int climbStairs(int n) {
        if (n <= 1) return 1;  // 处理基础情况
        int[] memo = new int[n + 1];  // 创建记忆化数组
        memo[0] = 1;  // 初始化基础情况
        memo[1] = 1;  // 初始化基础情况
        return helper(n, memo);  // 调用递归函数
    }

    private int helper(int n, int[] memo) {
        if (memo[n] != 0) return memo[n];  // 如果已计算过，直接返回结果
        memo[n] = helper(n - 1, memo) + helper(n - 2, memo);  // 递归计算并存储结果
        return memo[n];  // 返回计算结果
    }
}
```

### 1. **递推关系的本质**

java

```
f(n) = f(n-1) + f(n-2)
```



- `f(n-1)`：从n-1阶爬1阶上来 → 只有1种爬法，但有`f(n-1)`种到达n-1阶的方法
- `f(n-2)`：从n-2阶爬2阶上来 → 只有1种爬法，但有`f(n-2)`种到达n-2阶的方法

### 2. **基础情况的初始化**

java

```
memo[0] = 1;  // 0阶：不爬也是一种方法
memo[1] = 1;  // 1阶：只能爬1阶
```



这是递归的"基石"，所有计算都建立在这两个基础值之上。

### 3. **数组长度的设计**

java

```
int[] memo = new int[n + 1];
```



- 需要存储从`memo[0]`到`memo[n]`共**n+1**个值
- 索引i对应第i阶楼梯的方法数

### 4. **记忆化技术的精妙之处**

java

```
if (memo[n] != 0) return memo[n];
```



这个语句有双重作用：

- **递归终止**：当递归到memo[0]和memo[1]时停止
- **避免重复计算**：确保每个子问题只计算一次

## 🔄 完整的思维流程

### 阶段1：问题分解（自顶向下）

text

```
要算f(4)
→ 需要f(3)和f(2)
  → f(3)需要f(2)和f(1)
    → f(2)需要f(1)和f(0)
```



### 阶段2：结果积累（自底向上）

text

```
f(0)=1, f(1)=1 → 基础
f(2)=f(1)+f(0)=1+1=2
f(3)=f(2)+f(1)=2+1=3  
f(4)=f(3)+f(2)=3+2=5
```



### 阶段3：记忆化优化

text

```
计算f(4)时：
第一次需要f(2)：计算并存储memo[2]=2
第二次需要f(2)：直接返回memo[2]=2（避免重复计算）
```



## 📊 可视化执行过程（n=4）

text

```
递归调用栈：
helper(4)
├── helper(3) [未计算]
│   ├── helper(2) [未计算]  
│   │   ├── helper(1) [已初始化→返回1]
│   │   └── helper(0) [已初始化→返回1]
│   │   → memo[2] = 1+1 = 2
│   └── helper(1) [已初始化→返回1]
│   → memo[3] = 2+1 = 3
└── helper(2) [已计算→直接返回2]
→ memo[4] = 3+2 = 5
```

首先递推的根本就是f(n) = f(n-1) + f(n-2)，n阶有多少中方法，首先n-1是只有一种方法，其次n-2阶可以一次两阶达到n阶，所以最终n阶的方法和等于n-1的方法总和加上n-2的方法总和；首先需初始化0阶和1阶为1，0代表不爬，不爬也是一种方法，1代表一阶，只有一种方法，也就是爬一阶，在main栈中，递归的终止条件就是达到最底层也就是达到0阶（递推到f（2））或者1阶，用一个数组memo来存储每一阶需要的方法数，索引就是n阶，值是方法数，但是由于会递归到0阶，最终是n阶，所以动态数组的长度设置为n+1；递归中还有一个记忆条件if (memo[n] != 0) return memo[n];因为第一次递归的阶数，方法数都是0，是需要不断往下递归的，但是有些阶层递归也会遇到相同重复的阶层方法数，所以直接拿来用返回那个索引下的方法数就行，然后就是递推的逻辑
