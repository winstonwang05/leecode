# LeetCode 20 — 有效的括号

1. **问题本质**
   - 括号必须成对出现，并且不同类型的括号要按照正确的顺序匹配。
   - 这类「匹配」问题天然适合用 **栈** 来解决，因为栈是 **后进先出 (LIFO)** 的结构，正好和括号匹配顺序一致。
2. **核心思路**
   - 遍历字符串：
     - 遇到左括号就入栈；
     - 遇到右括号时，检查栈是否为空，如果为空说明没有可匹配的左括号，返回 `false`；否则取出栈顶元素，判断是否和当前右括号匹配，不匹配则返回 `false`。
   - 遍历完成后，栈应为空，才说明所有括号匹配成功。
3. **关键细节**
   - 如果字符串长度是奇数，可以直接返回 `false`（因为括号必须两两配对）。
   - 遍历过程中随时可能失败：
     - 栈为空却遇到右括号；
     - 栈顶元素与当前右括号不对应。
   - 最后要判断栈是否为空，否则有剩余左括号未匹配。
4. **栈的巧妙性**
   - 栈保证了「最后进入的左括号，必须最先匹配上对应的右括号」，这正是括号嵌套的要求。
   - 例如：输入 `({[]})`，入栈顺序是 `(` → `{` → `[`，出栈顺序正好相反，依次和 `]` → `}` → `)` 匹配。
5. **实现步骤总结**
   - 如果长度为奇数，返回 `false`；
   - 遍历字符串：
     - 左括号入栈；
     - 右括号检查匹配，否则返回 `false`；
   - 遍历结束，返回栈是否为空。

## 6. 复杂度分析

- **时间复杂度**：O(n)
  遍历字符串一遍，每个字符最多进栈/出栈一次。
- **空间复杂度**：O(n)
  最坏情况下全是左括号，需要全部压栈。

------

## 7. 常见面试追问

1. **为什么用 `Deque` 而不是 `Stack`？**

   - `Stack` 是早期类，继承自 `Vector`，线程安全导致性能差。
   - `ArrayDeque` 更轻量，推荐作为栈的实现。

2. **能否优化空间复杂度到 O(1)？**

   - 不行。最坏情况（全是左括号）需要存储所有未匹配括号。
   - 因此 O(n) 空间不可避免。

3. **如果输入包含其他字符怎么办？**

   - 一般题目保证输入只含括号。
   - 如果可能包含其他字符，可以选择忽略或判定非法，视具体需求而定。

4. **空字符串该返回什么？**

   - 返回 `true`（因为没有任何不匹配）。

     

### 返回 `false` 的典型几种情况

1. **右括号多余（提前匹配失败）**

   ```
   输入: ")("
   ```

   - 一开始就遇到 `)`，栈是空的，说明没有左括号和它匹配 → `false`。

2. **左右类型不匹配**

   ```
   输入: "(]"
   ```

   - 栈顶是 `(`，遇到 `]` 时无法匹配 → `false`。

3. **遍历结束后栈非空（左括号多余）**

   ```
   输入: "((("
   ```

   - 没有足够的右括号来消耗栈里的 `(`，最后栈不为空 → `false`。

------

### 换句话说

- **匹配过程中失败 → false**
- **遍历完成后，栈还残留元素 → false**
- **只有完全匹配并且栈为空 → true**

```

```


