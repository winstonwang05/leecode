# 206.反转链表

## 	思路一：迭代法（双指针）

​

```
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;      // 已反转部分的头（开始为空）
        ListNode cur = head;       // 当前正在处理的结点
        while (cur != null) {
            ListNode next = cur.next; // 1) 先保存下一个结点，避免丢失剩余链表
            cur.next = prev;          // 2) 断开并反转指针：当前结点指向已反转部分
            prev = cur;               // 3) prev 前进（已反转链表增加一个结点）
            cur = next;               // 4) cur 前进到剩余链表的下一个结点
        }
        return prev; // prev 指向新的头结点（当 cur 变为 null 时）
    }
}

```

### while 循环里的三个动作

假设当前处理的结点是 `cur`，上一次反转完成的链表头是 `pre`：

1. **保存后继结点**

   ```
   next = cur.next;
   ```

   👉 保存原链表中当前结点的下一个结点，避免丢失。

2. **反转指针**

   ```
   cur.next = pre;
   ```

   👉 让当前结点指向 `pre`（已经反转好的部分）。这一步就是“反转”的本质。

3. **推进指针**

   ```
   pre = cur;
   cur = next;
   ```

   👉 更新 `pre` 和 `cur`，准备处理下一个结点。



### 迭代反转链表的流程（标准表述）

1. **初始化**
   - 先把反转链表的头结点 `pre` 设为 `null`，因为反转之后原链表的头结点要指向 `null`。
   - 用 `cur` 指向原链表的头结点，表示当前正在处理的结点。
2. **循环条件**
   - 当 `cur != null` 时继续循环，一旦 `cur` 为空，说明已经遍历完整个链表，反转完成。
3. **循环体**
   - 保存下一个结点：`next = cur.next`（防止反转指针后丢失剩余链表）。
   - 反转当前结点：`cur.next = pre`（让当前结点指向已经反转好的部分）。
   - 推进反转链表：`pre = cur`（把当前结点作为新的头结点）。
   - 继续遍历：`cur = next`（处理原链表的下一个结点）。
4. **结束返回**
   - 当循环结束时，`pre` 指向的就是反转后链表的头结点，直接返回即可。

### 个人理解表述：

​	首先将反转后的头节点设为null，因为头节点反转之后指向的就是null，所以我们就要从这开始，再把头节点赋值给cur表示当前结点，以便后面反转链表拼接；循环结束的条件是一旦遍历到某个结点为空，那么说明原链表已经反转完成了；通过执行的结点再原链表中指向下一个结点信息赋值为next，其实就是为了下一次迭代/遍历的结点；再将执行到当前结点指向下一个结点cur.next为pre（即cur.next = pre）这里就是将链表顺序反过来了，然后为了推进反转链表，将cur赋值给pre，供给下一次迭代结点指向；最后将原来的next = cur，所以下一次迭代就从这个next开始

### 原链表方向

- **原链表**：从左到右

  ```
  head → node1 → node2 → node3 → … → null
  ```

- **反转后链表**：从右到左

  ```
  nodeN → … → node3 → node2 → node1 → null
  ```

也就是说，原链表的 **头结点**（最左边）会变成反转后链表的 **尾结点**（最右边，指向 null）。
原链表的 **尾结点**（最右边）会变成反转后链表的 **头结点**。

## 	思路二：递归法



这样看

```
head.next.next = head; // head.next看作一个整体表示原链表的中当前结点指向下一个结点地址，在这基础上（head.next）.next = head 表示这个结点指向当前执行的结点，就是反向了
head.next = null; // 将当前结点的指向为null 
```



### 递归反转链表的思路（详细）

1. **基准情况**

   - 如果 `head == null`：说明是空链表，直接返回 `null`。
   - 如果 `head.next == null`：说明递归到了最后一个节点（尾节点），直接返回它作为反转后链表的新头。

2. **递归过程**

   - 调用 `reverseList(head.next)`，去反转后面部分的链表。递归会一直到底，到最后一个节点返回。
   - 假设返回值 `newHead` 始终指向反转后的新头节点。

3. **回溯阶段调整指针**

   - 关键操作：

     ```
     head.next.next = head;
     head.next = null;
     ```

     含义：

      - `head.next.next = head`：让原本指向 `head` 的下一个节点反过来指向 `head`。
      - `head.next = null`：断开当前节点和后续节点的原始连接，避免环。

4. **返回结果**

   - 每一层递归都返回 `newHead`，即最初的尾节点。
   - 当递归完全展开时，整个链表已经反转完成。

------

### 举个例子：原链表 `4 → 5 → null`

- **递归到底**：到节点 `5`，返回 `5`。
- **回溯到节点 4**：
   - `head = 4`，`head.next = 5`。
   - 执行 `head.next.next = head` → `5.next = 4`，此时链表变成 `5 → 4`。
   - 执行 `head.next = null` → `4.next = null`，链表变成 `5 → 4 → null`。
   - 返回 `newHead = 5`。

最终返回 `5 → 4 → null`。

首先判断head是否为空，为空说明就是空链表，然后再判断当前结点指向下一个结点信息是否为null，为null说明就一个结点，后面没有了，也可以说是遍历的原链表的最后一个，因为递归到原链表的最后一个结点的指向下一个结点信息就是null；然后递归，通过把 当前结点信息 设置给 当前结点在原链表指向下一个结点信息在这基础上next表示指向，相当于是链表反转了，指向方向顺序反过来了，接着将当前结点指向下一个结点信息为null，怕出现环形链表，返回的结果就是（比如head 为 4 ，那么就是5 ->4 ->null）,一直回溯到原链表头结点时，首先newhead 就是 头结点在原链表中指向下一个结点信息然后反转到当前位置 （..原链表下一个结点->null）所以 head.next.next = head;   head.next = null;然后得到（..原链表下一个结点->头结点->null）

### 原链表头结点也就是回溯到最外层递归

<img width="1088" height="738" alt="image" src="https://github.com/user-attachments/assets/40ffd948-aba5-48c9-9e40-97ed9031f7f2" />

就是递归到最外层的时候
