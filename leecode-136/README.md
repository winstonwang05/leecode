# 136.只出现一次的数字

## 思路一：排序后遍历

```
class Solution {
    public int singleNumber(int[] nums) {
        Arrays.sort(nums);
        if (nums.length == 1) return nums[0];
        for (int i = 0; i < nums.length - 1; i += 2) {
            if (nums[i] != nums[i + 1]) {
                return nums[i];
            }
        }
        return nums[nums.length - 1]; 
    }
}

```

### 1. 遍历到倒数第二个索引就结束

- 因为循环体里要访问 `nums[i+1]`，所以条件必须是 `i < n - 1`，这样才能保证不越界。
- 这意味着最后一个元素不会在循环里被访问，但这正好是我们想要的兜底逻辑。

### 2. 每次跳过一个元素继续遍历

- 成对的数字在排序后一定是相邻的，所以用 `i += 2` 可以一次性跳过一对。
- 如果 `nums[i] == nums[i+1]`，说明这一对是正常的，就直接跳过。
- 如果 `nums[i] != nums[i+1]`，那 `nums[i]` 就是唯一的数字，直接返回。

### 3. 如果循环结束还没返回

- 说明前面所有的数字都成对出现了。
- 那么唯一的数字一定在最后一个位置，所以直接 `return nums[n-1]`。

### 举个例子

数组 `[2,2,4,4,5]`：

- i=0 → 比较 `2` 和 `2` → 相等 → 跳过
- i=2 → 比较 `4` 和 `4` → 相等 → 跳过
- 循环结束（i=4 不满足 `< n-1`）
- 返回 `nums[n-1] = 5` ✅

数组 `[1,2,2,3,3]`：

- i=0 → 比较 `1` 和 `2` → 不相等 → 返回 `1` ✅

遍历到到倒数第二个索引位置就结束，每次遍历中间就跳过一个元素继续遍历，如果是第一个索引下就出现一次，那么其实直接就返回了，所以跳过不用担心跳过出现问题，最后遍历结束都没有返回值，那么就是最后一个索引了

## 思路二：异或法

```
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for (int num : nums) {
            res ^= num;
        }
        return res;
    }
}

```

### 逻辑拆解

1. **初始化**：`res = 0`
2. **遍历**：对每个元素 `num`，执行 `res = res ^ num`
3. **抵消**：因为 `a ^ a = 0`，所有出现两次的数都会变成 0
4. **保留**：因为 `0 ^ b = b`，最后只剩下那个只出现一次的数

### 为什么这样成立

- **成对的数字会互相抵消**： 因为 `a ^ a = 0`。
- **0 不影响结果**： 因为 `0 ^ b = b`。
- **结合律和交换律**： 遍历顺序不影响结果，所有成对的数都会消掉，剩下的就是唯一的数。