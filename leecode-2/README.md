# 2.两数相加

### 方法：**模拟竖式加法 + 链表遍历**

```
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    // 1. 创建虚拟节点（三个作用）
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    int carry = 0;
    
    // 2. 循环条件：l1不为空 OR l2不为空 OR 有进位
    while (l1 != null || l2 != null || carry != 0) {
        // 3. 处理可能为空的节点
        int val1 = (l1 != null) ? l1.val : 0;
        int val2 = (l2 != null) ? l2.val : 0;
        
        // 4. 模拟竖式加法
        int total = val1 + val2 + carry;
        carry = total / 10;  // 更新进位
        int digit = total % 10;  // 当前位数字
        
        // 5. 构建结果链表
        current.next = new ListNode(digit);
        current = current.next;
        
        // 6. 移动指针（只有当前节点不为空时才移动）
        if (l1 != null) l1 = l1.next;
        if (l2 != null) l2 = l2.next;
    }
    
    // 7. 返回纯净的结果链表
    return dummy.next;
}
```

### 为什么不需要反转？

因为**逆序存储的方式正好符合我们做加法的自然顺序**！

回想一下小学学的竖式加法：

text

```
  342
+ 465
------
  807
```



我们是从**右边开始（个位）** 往左算的：

1. 先算 2 + 5 = 7（个位）
2. 再算 4 + 6 = 10，写0进1（十位）
3. 最后算 3 + 4 + 1 = 8（百位）

而链表 `2→4→3` 和 `5→6→4` 正好是**个位在头部**，所以我们只需要：

1. 从两个链表的**头部开始直接相加**
2. 处理进位
3. 同时向**下一个节点移动**

**整个过程完全不需要反转！**

# 整个思路实现过程



## 🔑 两数相加的核心理解

1. **和小学竖式加法类似**
   从最低位开始逐位相加，每一位的和可能会产生进位，带到下一位。
2. **虚拟头结点的作用**
   - 避免特殊处理链表头结点，统一操作逻辑。
   - 返回时只需返回 `dummy.next`，保证结果链表干净。
   - 初始化时赋任意值（通常是 0），实际不会用到。
3. **循环条件**
   `while (l1 != null || l2 != null || carry != 0)`
   - 只要还有链表没走完，或者存在进位，就继续计算。
   - 这样能覆盖三种情况：
     - 两链表都走完 & 无进位 → 结束。
     - 两链表都走完 & 有进位 → 继续处理进位。
     - 链表不等长 → 短链表部分当 0 处理。
4. **每轮迭代的操作**
   - 取当前节点值，若为空则按 0 处理。
   - 当前和：`sum = x + y + carry`
   - 更新进位：`carry = sum / 10`
   - 结果当前位：`digit = sum % 10`，挂到结果链表上。
   - 移动三个指针：结果链表指针、l1、l2（如果非空）。
5. **循环结束**
   返回 `dummy.next`，得到最终结果链表。

------

## 🎤 面试时可以这样说（精简版）

> 这道题和小学的竖式加法类似，从最低位开始逐位相加，用一个变量记录进位。
> 我会先创建一个虚拟头结点，避免链表头部的特殊处理，最后返回 `dummy.next`。
> 循环条件是 l1、l2 其中一个不为空，或者有进位。每次取出当前位相加，如果链表节点为空就当作 0 处理。
> 然后更新进位，把余数作为新节点加到结果链表里，最后移动三个指针。
> 循环结束直接返回虚拟节点的下一个，就是题目要求的结果链表。

理解：链表逆序相加和小学的竖线加法有相似；首先new一个虚拟节点，这里虚拟节点三个作用，一个作用是避免链表头空情况，因此不需要判空处理，第二个是得到纯净的链表，返回结果也比较方便，第三个作用是变为题目要求的链表并返回；并将虚拟节点赋值一个随机变量，也是为了保证虚拟节点所在的链表保证纯净；首先定义一个变量并初始化为0，表示进位信息，然后循环的条件是两个链表不为空，并且进位不为0，三个条件之间取逻辑或，逻辑或（||）一旦出现true就是true，只有全部是false最终才是false；这里就有几种情况，第一种是两个链表长度相等到达了最后一个节点，没有进位，那么都是false循环结束，两个链表长度相同到达最后一个节点，有进位，就会进入循环处理进位并让cur指向；进入循环判断两个链表当前节点是否为null，如果为null那么就直接返回0，方便长度不等的链表，长的链表还能继续进入循环进位，并让虚拟节点链表指向；然后就是进位操作，通过相加两个链表的当前链表以及加上上一次进位的结果（和小学的竖线加法一样的），通过取商/然后更新进位，以便下一次的两个节点相加的结果加上进位，然后取%是得到余数是为了虚拟节点所在链表的指向下一个节点指针；接着就是指向下一个指针，并向右移动指针位置；然后还需要移动两个链表，但是有可能两个链表到达最后一个节点，所以需要判断当前节点不为null才能移动指针，不是判断下一个节点为null，因为为null进来赋值为0，保证长链表能相加；循环结束，直接返回虚拟节点的下一个指针就行
