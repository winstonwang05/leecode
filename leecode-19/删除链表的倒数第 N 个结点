# 19.删除链表的倒数第N个结点

## 思路：快慢指针

```
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 创建虚拟头节点
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // 初始化快慢指针
        ListNode fast = dummy;
        ListNode slow = dummy;

        // 快指针先走 n+1 步
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
        }

        // 快慢指针同时前进
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }

        // 删除目标节点
        slow.next = slow.next.next;

        // 返回新链表头
        return dummy.next;
    }
}

```

## ✅ 删除链表的倒数第 N 个结点 — 思路理解

首先，我们需要删除的是链表的倒数第 N 个结点。
 由于倒数第 N 个结点距离末尾结点的长度是 `N - 1`，
 那么它的**上一个结点**（也就是要修改指针的那个结点）距离末尾结点的长度就是 `N`。

------

### 🧠 一、思路分析

为了方便删除，我们需要先找到**删除结点的上一个结点**，
 因为只有拿到它，我们才能通过 `slow.next = slow.next.next` 来跳过目标结点。

因此，我们可以使用 **快慢指针（two pointers）**：

- 让**快指针 fast** 和 **慢指针 slow** 同时从同一起点出发；
- 让快指针 **先走 N+1 步**；
- 这样两者之间就始终保持 **N+1 的固定间距**。

为什么是 N+1 而不是 N？
 因为我们希望当快指针到达链表末尾的“下一个节点”（即 `null`）时，
 慢指针刚好停在 **待删除节点的前一个节点**。

此时慢指针距离末尾的距离正好是 N，
 而快指针比它多走 1 步走到了 `null`，
 因此满足我们删除节点所需的定位条件。

------

### ⚙️ 二、实现细节

1. **定义虚拟头节点（dummy）**
    在链表头之前新建一个虚拟节点 `dummy`，
    令 `dummy.next = head`，这样即使删除的是头节点，也不需要额外判空处理。
2. **初始化双指针**
    让 `fast` 和 `slow` 都指向 `dummy`，从虚拟头节点开始。
3. **快指针先走 N+1 步**
    这样保证快慢指针之间的距离始终是 N+1，
    这里的 `+1` 表示快指针本身所占的位置也算在距离内。
4. **同步移动快慢指针**
    当快指针移动到 `null`（即末尾结点的下一个位置）时，
    慢指针正好停在要删除节点的前一个节点。
5. **执行删除操作**
    让 `slow.next = slow.next.next`，跳过目标节点即可。
6. **返回结果**
    返回 `dummy.next`，即新的链表头节点。

------

### 💬 三、总结理解

> 整体思路就是：
>
> - 快指针先行 N+1 步，保持与慢指针固定间距；
> - 当快指针到达链表末尾的下一个位置时；
> - 慢指针刚好指向待删除节点的前一个节点；
> - 修改指针实现跳过目标节点即可。

通过引入虚拟头节点，可以避免头节点被删除时出现的特殊处理逻辑，
 从而让代码更简洁、更健壮。

白话理解：

这道题的理解：首先需要删除倒数第N个结点，需要删除的结点距离末尾结点长度就是N - 1，所以需要删除的结点上一个结点（逆向看链表）距离末尾结点长度就是N，因此我们可以定义快慢指针，需要保证慢指针下一个指向正好是需要删除的结点，因为我们需要得到删除结点的上一个结点，这个结点下一个指针指向就是删除结点，让这个指针下一个指向为下下个指针，这样来实现跳过，所以快指针需要和慢指针之间固定距离就是N+1，使快指针指向链表末尾结点下一个指向，肯定为null，遍历结束，此时慢指针离末尾结点正好就是原来与快指针的距离N+1 再减去 -1得到此时慢指针距离末尾结点距离就是N，原因就是快指针指向的是末尾结点下一个null结点；实现：通过定义一个虚拟结点在头结点之前，好处是以防头结点为空，不需要判空处理，使快慢指针首先指向虚拟节点，都从虚拟节点开始，最后返回就虚拟结点指向下一个指针，然后提前让快指针先走N+1步，保证快慢指针之间固定距离为N+1个结点，慢指针到快指针的距离就是中间结点数量加+1（1就是快指针此时的位置，需要加上才能到达快指针的所在相同位置），然后遍历链表，结束的条件就是快指针指向null也就是末尾结点的下一个指针，此时慢指针距离末尾结点正好就是N，所以需要将慢指针下一个指针（也就是需要删除的指针）指向下下个指针（也就是跳过），最后返回虚拟结点下一个指针就是最终结果
