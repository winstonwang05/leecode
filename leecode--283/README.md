# 283. 移动零
注意：题目中的一定顺序并不是升序，而是移动过程中与原来数据之间的顺序不变
### 双向指针

```
public class Solution {
    public void moveZeroes(int[] nums) {
        // 指向下一个指针
        int next = 0;
        // 遍历数组
        for (int i = 0; i < nums.length; i++) {
            // 只有i遍历的数值不为0才遍历
            if (nums[i] != 0) {
                nums[next] = nums[i];
                // 如果下一个指针和i指针不同，说明遍历到0了
                if (i != next) {
                    nums[i] = 0;
                }
                next++;
            }
        }
    }
}
```

首先j就是执行完代码就会执行下一个索引的指针也就是j++（其实就是实现了按照原数据的一定顺序），所以说是指向下一个，然后i是遍历数组每一个索引（i像是来追赶j指针），通过索引得到值，如果值为0，循环内部的代码是不执行的，就会还需要继续下一步循环，直到i指向的索引下值不为0，然后将值赋值给j此时指向的索引下的值，执行完代码，判断i和j是否相等，相等就说明i在遍历过程中并没有0，不相等说明中途i遍历到0了，导致最后两个索引不同，也就是i和j不同，所以说是j反正每次都是指向下一个索引，提前指向了，然后下一次i遍历就会指向j这里，i没遇到0就停止，此时这两个索引相等，并进行赋值），i遇到0就会往下继续遍历，肯定就会i和j不同，那么说明遇到0，将i在后面遍历的赋值为0

#### 图解

![demo](C:\Users\Winston\Desktop\demo.png)第一次

- `i=0` → 指向 `1`
- `j=0` → 指向 `1`
- 因为 `nums[i] != 0`，所以把 `nums[i]` 赋给 `nums[j]`，此时 `i` 和 `j` 相等，不需要清零。
- 然后 `j++` → 变成 1。

------

### 第二次

- `i=1` → 指向 `12`
- `j=1` → 指向 `12`
- `nums[i] != 0`，赋值给 `nums[j]`，两者相等，不清零。
- `j++` → 变成 2。

------

### 第三次

- `i=2` → 指向 `0`
- 因为 `nums[i] == 0`，循环体不执行，`j` 保持在 2。
- 等于说 **i 往前跑，j 停住等待下一个非零元素**。

------

### 第四次

- `i=3` → 指向 `11`
- `j=2` → 还在等候位置
- 因为 `nums[i] != 0`，所以把 `nums[i]`（11）放到 `nums[j]`（索引 2 的位置），然后清零原来 `nums[i]` 的位置。
- 结果变成 `[1, 12, 11, 0]`。
- 最后 `j++ = 3`。

<img width="420" height="1733" alt="双指针" src="https://github.com/user-attachments/assets/ade7a2db-7704-4e3f-9d10-21e8f947fd9a" />


